#!/usr/bin/env bash
set -euo pipefail

info() { echo -e "\e[92m[+] $@\e[0m"; }

# Default VM attributes - tuned for Github Actions runners by default
VM_NAME="${VM_NAME:-test-vm}"
VM_SERIES="${VM_SERIES:-22.04}"
VM_CPUS="${VM_CPUS:=1}"
VM_MEM_GIB="${VM_MEM_GIB:=6}"
VM_DISK_GIB="${VM_DISK_GIB:=12}"

SCREENSHOTS_PATH="${SNAP_REAL_HOME}/ghvmctl-screenshots"

# Starts a desktop VM and waits for the agent to be running inside.
prepare_vm() {
	info "Launching VM '${VM_NAME}' with LXD"
	lxc launch -q "images:ubuntu/${VM_SERIES}/desktop" "${VM_NAME}" --vm \
		-c limits.cpu="${VM_CPUS}" \
		-c limits.memory="${VM_MEM_GIB}GiB" \
		-d root,size="${VM_DISK_GIB}GiB"

	# Wait for the VM agent to be running
	while ! lxc exec test-vm -- cat /etc/hostname &>/dev/null; do
		sleep 2
	done

	info "Installing utilities in VM"

	# Push script runner into the VM
	lxc -q file push "${SNAP}/opt/ghvmctl/ghvmctl-runner" test-vm/bin/ghvmctl-runner
	lxc exec test-vm -- chmod 755 /bin/ghvmctl-runner

	lxc exec test-vm -- apt-get update -qq
	lxc exec test-vm -- apt-get install -y gnome-screenshot

	# Kill the gnome initial setup wizard
	pid="$(lxc exec test-vm -- pidof gnome-initial-setup)"
	lxc exec test-vm -- kill -9 "$pid"
}

# Exec a command in the VM using the wrapper.
exec_in_vm() {
	lxc exec test-vm -- sudo -u ubuntu bash -c "/bin/ghvmctl-runner $*"
}

# Takes a screenshot of the full screen and pulls the file back from the VM to a file
# named "screenshot-screen-$TIMESTAMP.png", last file is linked as "screenshot-screen.png".
screenshot_full() {
	info "Taking a screenshot of the full screen inside the VM"
	mkdir -p "${SCREENSHOTS_PATH}"
	# Take a screenshot of the whole screen in the VM
	timestamp="$(date +'%Y-%m-%d_%H%M%S')"
	exec_in_vm "gnome-screenshot -f /home/ubuntu/screen.png"
	# Pull the screenshot back to the host
	output="screenshot-screen-$timestamp.png"
	lxc file pull "${VM_NAME}/home/ubuntu/screen.png" "${SCREENSHOTS_PATH}/$output"
	ln -sf "$output" "${SCREENSHOTS_PATH}/screenshot-screen.png"
}

# Takes a screenshot of the active window and pulls the file back from the VM to a file
# named "screenshot-window-$TIMESTAMP.png", last file is linked as "screenshot-window.png".
screenshot_window() {
	info "Taking a screenshot of the active window inside the VM"
	mkdir -p "${SCREENSHOTS_PATH}"
	# Take a screenshot of the active window in the VM
	timestamp="$(date +'%Y-%m-%d_%H%M%S')"
	exec_in_vm "gnome-screenshot -w -f /home/ubuntu/window.png"
	# Pull the screenshot back to the host
	output="screenshot-window-$timestamp.png"
	lxc file pull "${VM_NAME}/home/ubuntu/window.png" "${SCREENSHOTS_PATH}/$output"
	ln -sf "$output" "${SCREENSHOTS_PATH}/screenshot-window.png"
}

# Print the usage statement and exit the program
usage() {
	cat <<EOF
ghvmctl is a utility for manipulating virtual machines during snap testing.

USAGE:
	ghvmctl <SUBCOMMAND> [OPTIONS]

SUBCOMMANDS:
	prepare
		Launches a new virtual machine, and prepares it for snap testing.

	exec
		Runs a command inside the virtual machine.

		Examples:
		  ghvmctl exec "cat /etc/hostname"
		  ghvmctl exec "sudo apt update"

	snap-install <snap name> [-c|--channel <channel>] [-r|--revision <revision>]
		Installs the specified snap inside the VM.

		Examples:
		  ghvmctl install snap terraform
		  ghvmctl install snap signal-desktop --channel candidate
		  ghvmctl install snap signal-desktop --revision 554

	snap-run <snap name>
		Runs the specified snap inside the VM. Outputs stdout/stderr to a file
		inside the VM at /home/ubuntu/<snap name>.log.
		Only one instance of a single snap can run.

		Examples:
		  ghvmctl run-snap signal-desktop

	snap-is-running <snap name>
		Checks whether the provided snap is currently running.
		Exits with a non-zero value if this is not the case.

		Examples:
		  ghvmctl snap-is-running signal-desktop

	snap-terminate <snap name>
		Terminates the provided snap, waiting for it to be stopped.
		Exits with a non-zero value if the snap is not running or stop fails.

		Examples:
		  ghvmctl snap-terminate signal-desktop

	snap-kill <snap name>
		Kills the provided snap (using SIGKILL), and waits for completion.
		Exits with a non-zero value if the snap is not running.

		Examples:
		  ghvmctl snap-kill signal-desktop

	screenshot-full
		Takes a full-screen screenshot of the virtual machine. Places the output
		at ~/ghvmctl-screenshots

	screenshot-window
		Takes a screenshot of the active window in the virtual machine. Places the output
		at ~/ghvmctl-screenshots
EOF
	exit 1
}

# Parse the subcommand and exit if empty, printing the usage
command="${1:-}"
shift
if [[ -z $command ]]; then
	usage
fi

function check_deprecated_command() {
	if  [[ "$1" == *-snap ]]; then
		echo "$0: $1 is deprecated, use snap-${1%-snap} instead."
	fi
}

case "$command" in
"prepare")
	prepare_vm
	;;
"exec")
	exec_in_vm "$@"
	;;
"snap-run"|"run-snap")
	check_deprecated_command "$command"
	if exec_in_vm systemctl -q --user is-active "snap.$1.*"; then
		echo "$1 is already running"
		exit 1
	fi
	exec_in_vm "snap run $1 &>/home/ubuntu/$1.log &"
	;;
"snap-install"|"install-snap")
	check_deprecated_command "$command"
	snap_name="$1"
	shift

	if ! VALID_ARGS=$(getopt -o c:r --long name:,channel:,revision: -- "$@"); then
		usage
	fi

	eval set -- "$VALID_ARGS"
	while true; do
		case "$1" in
			-c | --channel)
				exec_in_vm "sudo snap install $snap_name --channel $2 --classic"
				shift 2
				;;
			-r | --revision)
				exec_in_vm "sudo snap install $snap_name --revision $2 --classic"
				shift 2
				;;
			--)
				exec_in_vm "sudo snap install $snap_name --classic"
				shift
				break
				;;
		esac
	done
	;;
"snap-is-running")
	snap_name="$1"
	if ! exec_in_vm systemctl -q --user is-active "snap.$snap_name.*"; then
		echo Process for "$snap_name" not running.
		exit 1;
	fi
	;;
"snap-terminate")
	snap_name="$1"
	if ! exec_in_vm systemctl -q --user is-active "snap.$snap_name.*"; then
		echo Process for "$snap_name" not running.
		exit 1;
	fi
	exec_in_vm systemctl --user stop "snap.$snap_name.*"
	shift
	;;
"snap-kill")
	snap_name="$1"
	if ! exec_in_vm systemctl -q --user is-active "snap.$snap_name.*"; then
		echo Process for "$snap_name" not running.
		exit 1;
	fi
	exec_in_vm systemctl --user kill -s 9 "snap.$snap_name.*"
	shift
	;;
"screenshot-full")
	screenshot_full
	;;
"screenshot-window")
	screenshot_window
	;;
*)
	usage
	;;
esac
